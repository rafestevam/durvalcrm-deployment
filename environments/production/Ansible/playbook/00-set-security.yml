---
- name: Set Security and Create Let's Encrypt Certificates for Subdomains
  hosts: vm-production
  become: yes
  vars:
    main_domain: "cecairbar.org.br"
    cert_email: "admin@cecairbar.org.br"
    wildfly_home: "/opt/wildfly"
    wildfly_user: "wildfly"
    wildfly_group: "wildfly"
    letsencrypt_dir: "/etc/letsencrypt"
    certificates_dir: "/home/{{ ansible_user }}/certificates"
    
    # List of all subdomains to create certificates for
    subdomains:
      - name: "crm"
        full_domain: "crm.cecairbar.org.br"
        description: "CRM Frontend Application"
      - name: "api"
        full_domain: "api.cecairbar.org.br"
        description: "API Backend Service"
      - name: "admin"
        full_domain: "admin.cecairbar.org.br"
        description: "Keycloak Admin Console"
      - name: "wildfly"
        full_domain: "wildfly.cecairbar.org.br"
        description: "WildFly Application Server"
      - name: "management"
        full_domain: "management.cecairbar.org.br"
        description: "WildFly Management Console"
      - name: "directus"
        full_domain: "directus.cecairbar.org.br"
        description: "Directus CMS"
      - name: "home"
        full_domain: "cecairbar.org.br"
        description: "Home Page"
      - name: "www"
        full_domain: "www.cecairbar.org.br"
        description: "Home Page WWW"

  tasks:
    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install required packages for Let's Encrypt
      ansible.builtin.apt:
        name:
          - snapd
          - openssl
          - ca-certificates
          - python3-cryptography
          - default-jdk
          - nginx  # Needed for webroot plugin
          - lsof   # Needed for port checking
          - dnsutils  # Needed for nslookup
        state: present

    - name: Create certificate directory in ansible_user home
      ansible.builtin.file:
        path: "{{ certificates_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Create individual certificate directories for each subdomain
      ansible.builtin.file:
        path: "{{ certificates_dir }}/{{ item.name }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      loop: "{{ subdomains }}"

    - name: Install certbot via snap
      community.general.snap:
        name: certbot
        classic: yes
        state: present

    - name: Install certbot nginx plugin
      community.general.snap:
        name: certbot-dns-cloudflare
        classic: yes
        state: present
      ignore_errors: yes

    - name: Create symbolic link for certbot
      ansible.builtin.file:
        src: /snap/bin/certbot
        dest: /usr/bin/certbot
        state: link

    - name: Check which services are installed
      ansible.builtin.systemd:
        name: "{{ item }}"
      register: service_check
      loop:
        - apache2
        - nginx
        - wildfly
        - keycloak
      failed_when: false
      changed_when: false

    - name: Stop services that might use port 80/443 (only if installed)
      ansible.builtin.systemd:
        name: "{{ item.item }}"
        state: stopped
      loop: "{{ service_check.results }}"
      when: item.status is defined and item.status.LoadState == "loaded"
      ignore_errors: yes

    - name: Kill any process using port 80
      ansible.builtin.shell: |
        lsof -ti:80 | xargs -r kill -9
      failed_when: false
      changed_when: false

    - name: Kill any process using port 443
      ansible.builtin.shell: |
        lsof -ti:443 | xargs -r kill -9
      failed_when: false
      changed_when: false

    - name: Wait for ports to be released
      ansible.builtin.wait_for:
        port: "{{ item }}"
        state: stopped
        timeout: 30
      loop:
        - 80
        - 443
      ignore_errors: yes

    # Create a single certificate with all subdomains as SAN (Subject Alternative Names)
    - name: Generate domain list for certbot command
      ansible.builtin.set_fact:
        domain_list: "{{ subdomains | map(attribute='full_domain') | list | join(' -d ') }}"

    - name: Display domain list for certificate
      ansible.builtin.debug:
        msg:
          - "Creating Let's Encrypt certificate for domains:"
          - "{{ subdomains | map(attribute='full_domain') | list }}"
          - ""
          - "⚠️  Important Prerequisites:"
          - "   1. DNS must be configured for all domains to point to this server"
          - "   2. Ports 80 and 443 must be accessible from the internet"
          - "   3. No rate limiting from Let's Encrypt"

    - name: Get server public IP address
      ansible.builtin.set_fact:
        server_ip: "{{ ansible_default_ipv4.address }}"

    - name: Check DNS resolution for all domains with detailed IP check
      ansible.builtin.shell: |
        resolved_ip=$(dig +short {{ item.full_domain }} @8.8.8.8 | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
        if [ -z "$resolved_ip" ]; then
          echo "NOT_RESOLVED"
        else
          echo "$resolved_ip"
        fi
      register: dns_check
      loop: "{{ subdomains }}"
      failed_when: false
      changed_when: false

    - name: Analyze DNS results
      ansible.builtin.set_fact:
        dns_issues: "{{ dns_check.results | selectattr('stdout', 'ne', server_ip) | list }}"
        dns_ok: "{{ dns_check.results | selectattr('stdout', 'eq', server_ip) | list }}"

    - name: Display detailed DNS check results
      ansible.builtin.debug:
        msg:
          - "=========================================="
          - "DNS Resolution Check"
          - "=========================================="
          - ""
          - "Server IP: {{ server_ip }}"
          - ""
          - "Summary:"
          - "  ✅ Correct DNS: {{ dns_ok | length }}/{{ subdomains | length }}"
          - "  ❌ Wrong/Missing DNS: {{ dns_issues | length }}/{{ subdomains | length }}"
          - ""

    - name: Show each domain DNS status
      ansible.builtin.debug:
        msg:
          - "Domain: {{ item.item.full_domain }}"
          - "  Resolved IP: {{ item.stdout if item.stdout != 'NOT_RESOLVED' else '❌ NOT RESOLVED' }}"
          - "  Status: {{ '✅ OK' if item.stdout == server_ip else '❌ WRONG IP' if item.stdout != 'NOT_RESOLVED' else '❌ NOT CONFIGURED' }}"
      loop: "{{ dns_check.results }}"

    - name: Show DNS configuration instructions if there are issues
      ansible.builtin.debug:
        msg:
          - ""
          - "⚠️  DNS CONFIGURATION REQUIRED ⚠️"
          - "=========================================="
          - ""
          - "{{ dns_issues | length }} domain(s) have DNS issues."
          - ""
          - "REQUIRED ACTIONS:"
          - "1. Access your DNS provider (Hostinger, Cloudflare, etc.)"
          - "2. Add/Update A records to point to {{ server_ip }}"
          - "3. Wait for DNS propagation (5 minutes to 48 hours)"
          - "4. Verify with: nslookup {{ dns_issues[0].item.full_domain }} 8.8.8.8"
          - "5. Re-run this playbook after DNS is fixed"
          - ""
          - "⚠️  Certificate generation will FAIL without correct DNS!"
          - "=========================================="
      when: dns_issues | length > 0

    - name: Show each problematic domain
      ansible.builtin.debug:
        msg:
          - "• {{ item.item.full_domain }}"
          - "  Current IP: {{ item.stdout if item.stdout != 'NOT_RESOLVED' else 'Not configured' }}"
          - "  Required IP: {{ server_ip }}"
          - "  Required DNS: {{ item.item.full_domain }}    A    {{ server_ip }}"
      loop: "{{ dns_issues }}"
      when: dns_issues | length > 0

    - name: Pause to allow user to fix DNS before continuing
      ansible.builtin.pause:
        prompt: |

          ⚠️  DNS ISSUES DETECTED! ⚠️

          {{ dns_issues | length }} domain(s) do not point to this server ({{ server_ip }}).
          Let's Encrypt certificate generation will FAIL without correct DNS.

          Options:
          1. Press Ctrl+C then 'A' to ABORT and fix DNS first (RECOMMENDED)
          2. Press ENTER to CONTINUE anyway (will likely fail)

          What do you want to do?
      when: dns_issues | length > 0

    - name: Obtain Let's Encrypt certificate for all subdomains using standalone mode
      ansible.builtin.shell: |
        certbot certonly --standalone \
          --non-interactive \
          --agree-tos \
          --email {{ cert_email }} \
          -d {{ domain_list }} \
          --expand \
          --force-renewal
      register: certbot_result
      failed_when: false
      vars:
        domain_list: "{{ subdomains | map(attribute='full_domain') | join(' -d ') }}"

    - name: Show certbot result
      ansible.builtin.debug:
        msg:
          - "Certbot execution result:"
          - "Return code: {{ certbot_result.rc }}"
          - "Status: {{ 'SUCCESS ✅' if certbot_result.rc == 0 else 'FAILED ❌' }}"
          - ""
          - "Output:"
          - "{{ certbot_result.stdout_lines }}"

    - name: Show certbot errors if failed
      ansible.builtin.debug:
        msg:
          - ""
          - "Errors:"
          - "{{ certbot_result.stderr_lines }}"
      when: certbot_result.rc != 0

    - name: Check if certbot failed and provide troubleshooting
      ansible.builtin.debug:
        msg:
          - "❌ Certificate generation FAILED!"
          - ""
          - "⚠️  WARNING: The playbook will continue, but certificate-dependent tasks will be skipped."
          - ""
          - "Common causes:"
          - "  1. DNS not configured: Domains must resolve to {{ ansible_default_ipv4.address }}"
          - "     {{ '❌ DETECTED: ' + (dns_issues | length | string) + ' domain(s) with wrong/missing DNS' if dns_issues | length > 0 else '' }}"
          - "  2. Firewall blocking: Ports 80/443 must be open"
          - "  3. Rate limiting: Let's Encrypt limits certificate requests"
          - "  4. Domain validation failed: ACME challenge couldn't be completed"
      when: certbot_result.rc != 0

    - name: Show DNS issues detail if present
      ansible.builtin.debug:
        msg:
          - ""
          - "🔍 DNS Issues Found:"
          - "{{ dns_issues | length }} domain(s) with DNS problems"
          - ""
          - "FIX DNS FIRST! Configure A records to point to {{ server_ip }}"
      when: certbot_result.rc != 0 and dns_issues | length > 0

    - name: Show each DNS issue
      ansible.builtin.debug:
        msg: "   • {{ item.item.full_domain }}: {{ item.stdout if item.stdout != 'NOT_RESOLVED' else 'Not configured' }} (should be {{ server_ip }})"
      loop: "{{ dns_issues }}"
      when: certbot_result.rc != 0 and dns_issues | length > 0

    - name: Show general troubleshooting steps
      ansible.builtin.debug:
        msg:
          - ""
          - "Troubleshooting:"
          - "  1. {{ 'FIX DNS CONFIGURATION (see above)' if dns_issues | length > 0 else 'Run diagnostic: ansible-playbook -i inventory/hosts.ini playbook/00-diagnose-letsencrypt.yml' }}"
          - "  2. Check LETSENCRYPT-TROUBLESHOOTING.md for detailed guide"
          - "  3. Verify DNS: dig +short crm.cecairbar.org.br @8.8.8.8"
          - "  4. Check firewall: sudo ufw status"
          - "  5. Check ports: sudo lsof -i :80 && sudo lsof -i :443"
          - "  6. View detailed logs: sudo tail -100 /var/log/letsencrypt/letsencrypt.log"
          - ""
          - "To retry manually after fixing DNS:"
          - "  sudo certbot certonly --standalone --non-interactive \\"
          - "    --agree-tos --email {{ cert_email }} \\"
          - "    -d {{ subdomains | map(attribute='full_domain') | join(' -d ') }}"
          - ""
          - "Once DNS is fixed, re-run this playbook to complete the certificate setup."
      when: certbot_result.rc != 0

    # Use the first subdomain as the primary certificate directory
    - name: Set primary certificate domain
      ansible.builtin.set_fact:
        primary_domain: "{{ subdomains[0].full_domain }}"
      when: certbot_result.rc == 0

    - name: Copy Let's Encrypt certificate to main certificates directory
      ansible.builtin.copy:
        src: "{{ letsencrypt_dir }}/live/{{ primary_domain }}/fullchain.pem"
        dest: "{{ certificates_dir }}/server.crt"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
        remote_src: yes
      when: certbot_result.rc == 0

    - name: Copy Let's Encrypt private key to main certificates directory
      ansible.builtin.copy:
        src: "{{ letsencrypt_dir }}/live/{{ primary_domain }}/privkey.pem"
        dest: "{{ certificates_dir }}/server.key"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
        remote_src: yes
      when: certbot_result.rc == 0

    # Copy certificates to individual subdomain directories for organization
    - name: Copy certificates to individual subdomain directories
      ansible.builtin.copy:
        src: "{{ certificates_dir }}/{{ item[1] }}"
        dest: "{{ certificates_dir }}/{{ item[0].name }}/{{ item[1] }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "{{ '0600' if 'key' in item[1] else '0644' }}"
        remote_src: yes
      loop: "{{ subdomains | product(['server.crt', 'server.key']) }}"
      when: certbot_result.rc == 0

    - name: Generate PEM bundle (certificate + key) in main directory
      ansible.builtin.shell: |
        cat {{ certificates_dir }}/server.crt \
            {{ certificates_dir }}/server.key \
            > {{ certificates_dir }}/server.pem
      args:
        creates: "{{ certificates_dir }}/server.pem"
      when: certbot_result.rc == 0

    - name: Generate PEM bundles for individual subdomains
      ansible.builtin.shell: |
        cat {{ certificates_dir }}/{{ item.name }}/server.crt \
            {{ certificates_dir }}/{{ item.name }}/server.key \
            > {{ certificates_dir }}/{{ item.name }}/server.pem
      args:
        creates: "{{ certificates_dir }}/{{ item.name }}/server.pem"
      loop: "{{ subdomains }}"
      when: certbot_result.rc == 0

    - name: Set proper permissions for all PEM bundles
      ansible.builtin.file:
        path: "{{ certificates_dir }}/{{ item }}/server.pem"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      loop: "{{ [''] + (subdomains | map(attribute='name') | list) }}"
      vars:
        item: "{{ item if item else '' }}"
      when: certbot_result.rc == 0

    - name: Generate DH parameters for enhanced security (this may take a while)
      community.crypto.openssl_dhparam:
        path: "{{ certificates_dir }}/dhparam.pem"
        size: 2048
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      when: certbot_result.rc == 0

    - name: Setup automatic certificate renewal with all subdomains
      ansible.builtin.cron:
        name: "Renew Let's Encrypt certificates for all subdomains"
        minute: "0"
        hour: "2"
        job: "/usr/bin/certbot renew --quiet --post-hook 'systemctl reload nginx && systemctl restart wildfly && systemctl restart keycloak'"
        user: root
      when: certbot_result.rc == 0

    - name: Create PKCS12 keystore for Java applications
      community.crypto.openssl_pkcs12:
        action: export
        path: "{{ certificates_dir }}/keystore.p12"
        certificate_path: "{{ certificates_dir }}/server.crt"
        privatekey_path: "{{ certificates_dir }}/server.key"
        passphrase: "changeit"
        friendly_name: "durvalcrm-cert"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      when: certbot_result.rc == 0

    # ========== WILDFLY KEYSTORE CONFIGURATION ==========

    - name: Check if WildFly directory exists
      ansible.builtin.stat:
        path: "{{ wildfly_home }}"
      register: wildfly_dir_check

    - name: Create WildFly certificates directory
      ansible.builtin.file:
        path: "{{ wildfly_home }}/certificates"
        state: directory
        owner: "{{ wildfly_user }}"
        group: "{{ wildfly_group }}"
        mode: '0755'
        recurse: yes
      when: certbot_result.rc == 0 and wildfly_dir_check.stat.exists

    - name: Check if source PKCS12 keystore exists
      ansible.builtin.stat:
        path: "{{ certificates_dir }}/keystore.p12"
      register: pkcs12_keystore_check
      when: certbot_result.rc == 0

    - name: Create JKS keystore for WildFly management realm
      ansible.builtin.shell: |
        keytool -importkeystore \
          -srckeystore {{ certificates_dir }}/keystore.p12 \
          -srcstoretype PKCS12 \
          -srcstorepass changeit \
          -destkeystore {{ wildfly_home }}/certificates/management-production.keystore \
          -deststoretype JKS \
          -deststorepass production123 \
          -destkeypass production123 \
          -srcalias durvalcrm-cert \
          -destalias production-management \
          -noprompt 2>&1
      when: certbot_result.rc == 0 and wildfly_dir_check.stat.exists and pkcs12_keystore_check.stat.exists
      register: management_keystore_result
      failed_when: false

    - name: Create JKS keystore for WildFly application realm
      ansible.builtin.shell: |
        keytool -importkeystore \
          -srckeystore {{ certificates_dir }}/keystore.p12 \
          -srcstoretype PKCS12 \
          -srcstorepass changeit \
          -destkeystore {{ wildfly_home }}/certificates/application-production.keystore \
          -deststoretype JKS \
          -deststorepass production123 \
          -destkeypass production123 \
          -srcalias durvalcrm-cert \
          -destalias production-app \
          -noprompt 2>&1
      when: certbot_result.rc == 0 and wildfly_dir_check.stat.exists and pkcs12_keystore_check.stat.exists
      register: application_keystore_result
      failed_when: false

    - name: Set proper ownership and permissions for WildFly keystores
      ansible.builtin.file:
        path: "{{ wildfly_home }}/certificates/{{ item }}-production.keystore"
        owner: "{{ wildfly_user }}"
        group: "{{ wildfly_group }}"
        mode: '0600'
      loop:
        - management
        - application
      when: certbot_result.rc == 0 and wildfly_dir_check.stat.exists

    # ========== NGINX CERTIFICATE PREPARATION ==========

    - name: Create nginx certificate symbolic links
      ansible.builtin.file:
        src: "{{ certificates_dir }}/{{ item[1] }}"
        dest: "{{ certificates_dir }}/nginx-{{ item[0].name }}-{{ item[1] }}"
        state: link
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      loop: "{{ subdomains | product(['server.crt', 'server.key', 'server.pem']) }}"
      when: certbot_result.rc == 0
      ignore_errors: yes

    # ========== CERTIFICATE INFORMATION AND VERIFICATION ==========

    - name: Verify certificate contains all subdomains
      ansible.builtin.shell: |
        openssl x509 -in {{ certificates_dir }}/server.crt -text -noout | grep -A 10 "Subject Alternative Name"
      register: cert_san_check
      changed_when: false
      failed_when: false
      when: certbot_result.rc == 0

    - name: Display certificate Subject Alternative Names
      ansible.builtin.debug:
        msg:
          - "Certificate Subject Alternative Names:"
          - "{{ cert_san_check.stdout_lines if cert_san_check.rc == 0 else ['No SAN found or certificate read error'] }}"
      when: certbot_result.rc == 0

    - name: Generate comprehensive certificate information file
      ansible.builtin.copy:
        content: |
          DurvalCRM Let's Encrypt Multi-Domain Certificate Information
          ===========================================================
          Generated: {{ ansible_date_time.iso8601 }}
          Host: {{ ansible_hostname }}
          IP Address: {{ ansible_default_ipv4.address }}
          Certificate Authority: Let's Encrypt
          Validity: 90 days (automatically renewed daily at 2 AM)
          
          Domains Covered:
          {% for subdomain in subdomains %}
          - {{ subdomain.full_domain }} ({{ subdomain.description }})
          {% endfor %}
          
          Primary Certificate Files (valid for ALL subdomains):
          ====================================================
          - server.key: Private key (from Let's Encrypt)
          - server.crt: Let's Encrypt certificate (fullchain with all subdomains)
          - server.pem: Combined certificate and key (for Nginx, HAProxy, etc.)
          - dhparam.pem: Diffie-Hellman parameters
          - keystore.p12: PKCS12 keystore for Java applications (password: changeit)
          
          Individual Subdomain Directories:
          =================================
          {% for subdomain in subdomains %}
          {{ subdomain.name }}/ directory:
            - server.crt: Certificate (same as main, valid for all subdomains)
            - server.key: Private key (same as main)
            - server.pem: Combined certificate and key
          {% endfor %}
          
          WildFly Keystores (if WildFly is installed):
          ===========================================
          - management-production.keystore: JKS for WildFly management (password: production123, alias: production-management)
          - application-production.keystore: JKS for WildFly application (password: production123, alias: production-app)
          
          Auto-renewal Configuration:
          ===========================
          - Cron job configured to run daily at 2 AM
          - Command: /usr/bin/certbot renew --quiet
          - Post-renewal hooks: restart nginx, wildfly, and keycloak services
          
          NGINX Configuration Examples:
          =============================
          For each subdomain server block:
          
          server {
              listen 443 ssl http2;
              server_name crm.cecairbar.org.br;  # or any of the other subdomains
              
              ssl_certificate {{ certificates_dir }}/server.crt;
              ssl_certificate_key {{ certificates_dir }}/server.key;
              ssl_dhparam {{ certificates_dir }}/dhparam.pem;
              
              # ... rest of configuration
          }
          
          Certificate Verification:
          ========================
          To verify certificate: openssl x509 -in server.crt -text -noout
          To check SAN: openssl x509 -in server.crt -text -noout | grep -A 10 "Subject Alternative Name"
          To test SSL: openssl s_client -connect crm.cecairbar.org.br:443 -servername crm.cecairbar.org.br
          
        dest: "{{ certificates_dir }}/README-MultiDomain.txt"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
      when: certbot_result.rc == 0

    - name: Display certificate creation summary
      ansible.builtin.debug:
        msg:
          - "✅ Let's Encrypt multi-domain certificate created successfully!"
          - ""
          - "📋 Certificate Details:"
          - "   📁 Location: {{ certificates_dir }}/"
          - "   🏷️  Primary domain: {{ primary_domain }}"
          - "   📊 Total domains: {{ subdomains | length }}"
          - "   ⏰ Validity: 90 days (auto-renewal configured)"
          - ""
          - "🌐 Domains covered by this certificate:"
          - "   See certificate configuration for full domain list"
          - ""
          - "📁 Main certificate files:"
          - "   🔑 server.key - Private key"
          - "   📜 server.crt - Certificate (valid for all subdomains)"
          - "   📦 server.pem - Combined certificate + key"
          - "   🔒 dhparam.pem - DH parameters"
          - "   ☕ keystore.p12 - Java keystore (password: changeit)"
      when: certbot_result.rc == 0

    - name: Display WildFly keystore status
      ansible.builtin.debug:
        msg:
          - "🐺 WildFly Keystores:"
          - "{{ '   ✅ WildFly directory found: ' + wildfly_home if wildfly_dir_check.stat.exists else '   ❌ WildFly not found at ' + wildfly_home }}"
          - "{{ '   🔑 Management keystore: ' + ('SUCCESS' if management_keystore_result.rc == 0 else 'FAILED') if wildfly_dir_check.stat.exists else '   ℹ️  Install WildFly first, then run this playbook again' }}"
          - "{{ '   🔑 Application keystore: ' + ('SUCCESS' if application_keystore_result.rc == 0 else 'FAILED') if wildfly_dir_check.stat.exists else '' }}"
          - "{{ '   🔐 Keystore password: production123' if wildfly_dir_check.stat.exists else '' }}"
      when: certbot_result.rc == 0

    - name: Verify certificate validity and dates
      ansible.builtin.shell: |
        openssl x509 -in {{ certificates_dir }}/server.crt -noout -dates -subject
      register: cert_details
      changed_when: false
      when: certbot_result.rc == 0

    - name: Display certificate validity information
      ansible.builtin.debug:
        msg:
          - "📅 Certificate Validity:"
          - "{{ cert_details.stdout_lines }}"
      when: certbot_result.rc == 0

    - name: Test certificate for each subdomain
      ansible.builtin.shell: |
        echo | openssl s_client -connect {{ item.full_domain }}:443 -servername {{ item.full_domain }} -verify_return_error 2>/dev/null | openssl x509 -noout -subject
      register: cert_test
      changed_when: false
      failed_when: false
      loop: "{{ subdomains }}"
      when: certbot_result.rc == 0

    - name: Display per-domain certificate test results
      ansible.builtin.debug:
        msg:
          - "🧪 Certificate Tests (requires domains to be properly configured in DNS):"
          - "   Test results will vary based on DNS configuration"
          - ""
          - "ℹ️  Note: Failed tests are normal if DNS is not yet configured for these subdomains"
      when: certbot_result.rc == 0

    - name: Final setup instructions
      ansible.builtin.debug:
        msg:
          - ""
          - "🚀 Next Steps:"
          - "============="
          - "1. Configure your DNS to point all subdomains to this server's IP:"
          - "   {{ ansible_default_ipv4.address }}"
          - ""
          - "2. DNS Records needed:"
          - "   Point all configured subdomains to {{ ansible_default_ipv4.address }}"
          - ""
          - "3. Update your NGINX configuration to use the new certificate"
          - "4. Restart services: nginx, wildfly, keycloak"
          - ""
          - "5. Test each subdomain:"
          - "   All subdomains from configuration should work with HTTPS"
          - ""
          - "📖 For detailed information, see: {{ certificates_dir }}/README-MultiDomain.txt"
      when: certbot_result.rc == 0

    # ========== PLAYBOOK EXECUTION SUMMARY ==========

    - name: Playbook execution summary - Certificate generation FAILED
      ansible.builtin.debug:
        msg:
          - ""
          - "=========================================="
          - "   PLAYBOOK EXECUTION SUMMARY"
          - "=========================================="
          - ""
          - "Status: ⚠️  INCOMPLETE (Certificate generation failed)"
          - ""
          - "✅ Completed tasks:"
          - "   • Installed required packages (certbot, lsof, dnsutils, nginx)"
          - "   • Created certificate directories"
          - "   • Stopped services using ports 80/443"
          - "   • Cleaned up ports 80 and 443"
          - ""
          - "❌ Failed task:"
          - "   • Let's Encrypt certificate generation"
          - ""
          - "⚠️  Certificate-dependent tasks were SKIPPED:"
          - "   • Certificate file copying"
          - "   • PEM bundle generation"
          - "   • DH parameters generation"
          - "   • PKCS12/JKS keystore creation"
          - "   • NGINX symbolic links creation"
          - "   • Certificate verification"
          - ""
          - "📋 Next actions required:"
          - "   1. Run diagnostic: ansible-playbook -i inventory/hosts.ini playbook/00-diagnose-letsencrypt.yml"
          - "   2. Fix the identified issue (most likely DNS configuration)"
          - "   3. Re-run this playbook: ansible-playbook -i inventory/hosts.ini playbook/00-set-security.yml"
          - ""
          - "📚 Documentation:"
          - "   • LETSENCRYPT-TROUBLESHOOTING.md - Detailed troubleshooting guide"
          - "   • 00-diagnose-letsencrypt.yml - Diagnostic playbook"
          - "   • 00-fix-letsencrypt-issues.yml - Quick fix playbook"
          - ""
          - "=========================================="
      when: certbot_result.rc != 0

    - name: Playbook execution summary - SUCCESS
      ansible.builtin.debug:
        msg:
          - ""
          - "=========================================="
          - "   PLAYBOOK EXECUTION SUMMARY"
          - "=========================================="
          - ""
          - "Status: ✅ COMPLETED SUCCESSFULLY"
          - ""
          - "✅ All tasks completed:"
          - "   • Installed required packages"
          - "   • Generated Let's Encrypt certificate for {{ subdomains | length }} subdomains"
          - "   • Created certificate files (PEM, CRT, KEY)"
          - "   • Generated DH parameters for enhanced security"
          - "   • Created PKCS12 keystore for Java applications"
          - "{{ '   • Created JKS keystores for WildFly' if wildfly_dir_check.stat.exists else '   • WildFly not found (keystores skipped)' }}"
          - "   • Created NGINX symbolic links"
          - "   • Configured automatic renewal (daily at 2 AM)"
          - ""
          - "📁 Certificate location: {{ certificates_dir }}/"
          - "📜 Documentation: {{ certificates_dir }}/README-MultiDomain.txt"
          - ""
          - "🚀 Next steps:"
          - "   1. Update NGINX configuration to use the new certificates"
          - "   2. Deploy updated NGINX configuration"
          - "   3. Restart services (nginx, wildfly, keycloak)"
          - "   4. Test HTTPS access for all subdomains"
          - ""
          - "=========================================="
      when: certbot_result.rc == 0