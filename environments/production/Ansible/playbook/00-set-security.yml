---
- name: Set Security and Create Let's Encrypt Certificates for Subdomains
  hosts: vm-production
  become: yes
  vars:
    main_domain: "durvalcrm.org"
    cert_email: "admin@durvalcrm.org"
    wildfly_home: "/opt/wildfly"
    wildfly_user: "wildfly"
    wildfly_group: "wildfly"
    letsencrypt_dir: "/etc/letsencrypt"
    certificates_dir: "/home/{{ ansible_user }}/certificates"
    
    # List of all subdomains to create certificates for
    subdomains:
      - name: "crm"
        full_domain: "crm.durvalcrm.org"
        description: "CRM Frontend Application"
      - name: "api"
        full_domain: "api.durvalcrm.org"
        description: "API Backend Service"
      - name: "admin"
        full_domain: "admin.durvalcrm.org"
        description: "Keycloak Admin Console"
      - name: "wildfly"
        full_domain: "wildfly.durvalcrm.org"
        description: "WildFly Application Server"
      - name: "management"
        full_domain: "management.durvalcrm.org"
        description: "WildFly Management Console"

  tasks:
    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install required packages for Let's Encrypt
      ansible.builtin.apt:
        name:
          - snapd
          - openssl
          - ca-certificates
          - python3-cryptography
          - default-jdk
          - nginx  # Needed for webroot plugin
        state: present

    - name: Create certificate directory in ansible_user home
      ansible.builtin.file:
        path: "{{ certificates_dir }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Create individual certificate directories for each subdomain
      ansible.builtin.file:
        path: "{{ certificates_dir }}/{{ item.name }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      loop: "{{ subdomains }}"

    - name: Install certbot via snap
      community.general.snap:
        name: certbot
        classic: yes
        state: present

    - name: Install certbot nginx plugin
      community.general.snap:
        name: certbot-dns-cloudflare
        classic: yes
        state: present
      ignore_errors: yes

    - name: Create symbolic link for certbot
      ansible.builtin.file:
        src: /snap/bin/certbot
        dest: /usr/bin/certbot
        state: link

    - name: Stop services that might use port 80/443
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: stopped
      loop:
        - apache2
        - nginx
        - wildfly
        - keycloak
      ignore_errors: yes

    # Create a single certificate with all subdomains as SAN (Subject Alternative Names)
    - name: Generate domain list for certbot command
      ansible.builtin.set_fact:
        domain_list: "{{ subdomains | map(attribute='full_domain') | list | join(' -d ') }}"

    - name: Display domain list for certificate
      ansible.builtin.debug:
        msg: 
          - "Creating Let's Encrypt certificate for domains:"
          - "{{ subdomains | map(attribute='full_domain') | list }}"

    - name: Obtain Let's Encrypt certificate for all subdomains using standalone mode
      ansible.builtin.shell: |
        certbot certonly --standalone \
          --non-interactive \
          --agree-tos \
          --email {{ cert_email }} \
          -d {{ domain_list }} \
          --expand \
          --force-renewal
      register: certbot_result
      failed_when: certbot_result.rc != 0
      vars:
        domain_list: "{{ subdomains | map(attribute='full_domain') | join(' -d ') }}"

    - name: Show certbot result
      ansible.builtin.debug:
        msg:
          - "Certbot execution result:"
          - "Return code: {{ certbot_result.rc }}"
          - "Output: {{ certbot_result.stdout_lines }}"
          - "Error: {{ certbot_result.stderr_lines if certbot_result.stderr_lines is defined else 'No errors' }}"

    # Use the first subdomain as the primary certificate directory
    - name: Set primary certificate domain
      ansible.builtin.set_fact:
        primary_domain: "{{ subdomains[0].full_domain }}"

    - name: Copy Let's Encrypt certificate to main certificates directory
      ansible.builtin.copy:
        src: "{{ letsencrypt_dir }}/live/{{ primary_domain }}/fullchain.pem"
        dest: "{{ certificates_dir }}/server.crt"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'
        remote_src: yes

    - name: Copy Let's Encrypt private key to main certificates directory
      ansible.builtin.copy:
        src: "{{ letsencrypt_dir }}/live/{{ primary_domain }}/privkey.pem"
        dest: "{{ certificates_dir }}/server.key"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
        remote_src: yes

    # Copy certificates to individual subdomain directories for organization
    - name: Copy certificates to individual subdomain directories
      ansible.builtin.copy:
        src: "{{ certificates_dir }}/{{ item[1] }}"
        dest: "{{ certificates_dir }}/{{ item[0].name }}/{{ item[1] }}"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "{{ '0600' if 'key' in item[1] else '0644' }}"
        remote_src: yes
      loop: "{{ subdomains | product(['server.crt', 'server.key']) }}"

    - name: Generate PEM bundle (certificate + key) in main directory
      ansible.builtin.shell: |
        cat {{ certificates_dir }}/server.crt \
            {{ certificates_dir }}/server.key \
            > {{ certificates_dir }}/server.pem
      args:
        creates: "{{ certificates_dir }}/server.pem"

    - name: Generate PEM bundles for individual subdomains
      ansible.builtin.shell: |
        cat {{ certificates_dir }}/{{ item.name }}/server.crt \
            {{ certificates_dir }}/{{ item.name }}/server.key \
            > {{ certificates_dir }}/{{ item.name }}/server.pem
      args:
        creates: "{{ certificates_dir }}/{{ item.name }}/server.pem"
      loop: "{{ subdomains }}"

    - name: Set proper permissions for all PEM bundles
      ansible.builtin.file:
        path: "{{ certificates_dir }}/{{ item }}/server.pem"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'
      loop: "{{ [''] + (subdomains | map(attribute='name') | list) }}"
      vars:
        item: "{{ item if item else '' }}"

    - name: Generate DH parameters for enhanced security (this may take a while)
      community.crypto.openssl_dhparam:
        path: "{{ certificates_dir }}/dhparam.pem"
        size: 2048
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Setup automatic certificate renewal with all subdomains
      ansible.builtin.cron:
        name: "Renew Let's Encrypt certificates for all subdomains"
        minute: "0"
        hour: "2"
        job: "/usr/bin/certbot renew --quiet --post-hook 'systemctl reload nginx && systemctl restart wildfly && systemctl restart keycloak'"
        user: root

    - name: Create PKCS12 keystore for Java applications
      community.crypto.openssl_pkcs12:
        action: export
        path: "{{ certificates_dir }}/keystore.p12"
        certificate_path: "{{ certificates_dir }}/server.crt"
        privatekey_path: "{{ certificates_dir }}/server.key"
        passphrase: "changeit"
        friendly_name: "durvalcrm-cert"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0600'

    # ========== WILDFLY KEYSTORE CONFIGURATION ==========

    - name: Check if WildFly directory exists
      ansible.builtin.stat:
        path: "{{ wildfly_home }}"
      register: wildfly_dir_check

    - name: Create WildFly certificates directory
      ansible.builtin.file:
        path: "{{ wildfly_home }}/certificates"
        state: directory
        owner: "{{ wildfly_user }}"
        group: "{{ wildfly_group }}"
        mode: '0755'
        recurse: yes
      when: wildfly_dir_check.stat.exists

    - name: Check if source PKCS12 keystore exists
      ansible.builtin.stat:
        path: "{{ certificates_dir }}/keystore.p12"
      register: pkcs12_keystore_check

    - name: Create JKS keystore for WildFly management realm
      ansible.builtin.shell: |
        keytool -importkeystore \
          -srckeystore {{ certificates_dir }}/keystore.p12 \
          -srcstoretype PKCS12 \
          -srcstorepass changeit \
          -destkeystore {{ wildfly_home }}/certificates/management-production.keystore \
          -deststoretype JKS \
          -deststorepass production123 \
          -destkeypass production123 \
          -srcalias durvalcrm-cert \
          -destalias production-management \
          -noprompt 2>&1
      when: wildfly_dir_check.stat.exists and pkcs12_keystore_check.stat.exists
      register: management_keystore_result
      failed_when: false

    - name: Create JKS keystore for WildFly application realm
      ansible.builtin.shell: |
        keytool -importkeystore \
          -srckeystore {{ certificates_dir }}/keystore.p12 \
          -srcstoretype PKCS12 \
          -srcstorepass changeit \
          -destkeystore {{ wildfly_home }}/certificates/application-production.keystore \
          -deststoretype JKS \
          -deststorepass production123 \
          -destkeypass production123 \
          -srcalias durvalcrm-cert \
          -destalias production-app \
          -noprompt 2>&1
      when: wildfly_dir_check.stat.exists and pkcs12_keystore_check.stat.exists
      register: application_keystore_result
      failed_when: false

    - name: Set proper ownership and permissions for WildFly keystores
      ansible.builtin.file:
        path: "{{ wildfly_home }}/certificates/{{ item }}-production.keystore"
        owner: "{{ wildfly_user }}"
        group: "{{ wildfly_group }}"
        mode: '0600'
      loop:
        - management
        - application
      when: wildfly_dir_check.stat.exists

    # ========== NGINX CERTIFICATE PREPARATION ==========

    - name: Create nginx certificate symbolic links
      ansible.builtin.file:
        src: "{{ certificates_dir }}/{{ item[1] }}"
        dest: "{{ certificates_dir }}/nginx-{{ item[0].name }}-{{ item[1] }}"
        state: link
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      loop: "{{ subdomains | product(['server.crt', 'server.key', 'server.pem']) }}"
      ignore_errors: yes

    # ========== CERTIFICATE INFORMATION AND VERIFICATION ==========

    - name: Verify certificate contains all subdomains
      ansible.builtin.shell: |
        openssl x509 -in {{ certificates_dir }}/server.crt -text -noout | grep -A 10 "Subject Alternative Name"
      register: cert_san_check
      changed_when: false
      failed_when: false

    - name: Display certificate Subject Alternative Names
      ansible.builtin.debug:
        msg:
          - "Certificate Subject Alternative Names:"
          - "{{ cert_san_check.stdout_lines if cert_san_check.rc == 0 else ['No SAN found or certificate read error'] }}"

    - name: Generate comprehensive certificate information file
      ansible.builtin.copy:
        content: |
          DurvalCRM Let's Encrypt Multi-Domain Certificate Information
          ===========================================================
          Generated: {{ ansible_date_time.iso8601 }}
          Host: {{ ansible_hostname }}
          IP Address: {{ ansible_default_ipv4.address }}
          Certificate Authority: Let's Encrypt
          Validity: 90 days (automatically renewed daily at 2 AM)
          
          Domains Covered:
          {% for subdomain in subdomains %}
          - {{ subdomain.full_domain }} ({{ subdomain.description }})
          {% endfor %}
          
          Primary Certificate Files (valid for ALL subdomains):
          ====================================================
          - server.key: Private key (from Let's Encrypt)
          - server.crt: Let's Encrypt certificate (fullchain with all subdomains)
          - server.pem: Combined certificate and key (for Nginx, HAProxy, etc.)
          - dhparam.pem: Diffie-Hellman parameters
          - keystore.p12: PKCS12 keystore for Java applications (password: changeit)
          
          Individual Subdomain Directories:
          =================================
          {% for subdomain in subdomains %}
          {{ subdomain.name }}/ directory:
            - server.crt: Certificate (same as main, valid for all subdomains)
            - server.key: Private key (same as main)
            - server.pem: Combined certificate and key
          {% endfor %}
          
          WildFly Keystores (if WildFly is installed):
          ===========================================
          - management-production.keystore: JKS for WildFly management (password: production123, alias: production-management)
          - application-production.keystore: JKS for WildFly application (password: production123, alias: production-app)
          
          Auto-renewal Configuration:
          ===========================
          - Cron job configured to run daily at 2 AM
          - Command: /usr/bin/certbot renew --quiet
          - Post-renewal hooks: restart nginx, wildfly, and keycloak services
          
          NGINX Configuration Examples:
          =============================
          For each subdomain server block:
          
          server {
              listen 443 ssl http2;
              server_name crm.durvalcrm.org;  # or any of the other subdomains
              
              ssl_certificate {{ certificates_dir }}/server.crt;
              ssl_certificate_key {{ certificates_dir }}/server.key;
              ssl_dhparam {{ certificates_dir }}/dhparam.pem;
              
              # ... rest of configuration
          }
          
          Certificate Verification:
          ========================
          To verify certificate: openssl x509 -in server.crt -text -noout
          To check SAN: openssl x509 -in server.crt -text -noout | grep -A 10 "Subject Alternative Name"
          To test SSL: openssl s_client -connect crm.durvalcrm.org:443 -servername crm.durvalcrm.org
          
        dest: "{{ certificates_dir }}/README-MultiDomain.txt"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Display certificate creation summary
      ansible.builtin.debug:
        msg:
          - "✅ Let's Encrypt multi-domain certificate created successfully!"
          - ""
          - "📋 Certificate Details:"
          - "   📁 Location: {{ certificates_dir }}/"
          - "   🏷️  Primary domain: {{ primary_domain }}"
          - "   📊 Total domains: {{ subdomains | length }}"
          - "   ⏰ Validity: 90 days (auto-renewal configured)"
          - ""
          - "🌐 Domains covered by this certificate:"
          - "   See certificate configuration for full domain list"
          - ""
          - "📁 Main certificate files:"
          - "   🔑 server.key - Private key"
          - "   📜 server.crt - Certificate (valid for all subdomains)"
          - "   📦 server.pem - Combined certificate + key"
          - "   🔒 dhparam.pem - DH parameters"
          - "   ☕ keystore.p12 - Java keystore (password: changeit)"

    - name: Display WildFly keystore status
      ansible.builtin.debug:
        msg:
          - "🐺 WildFly Keystores:"
          - "{{ '   ✅ WildFly directory found: ' + wildfly_home if wildfly_dir_check.stat.exists else '   ❌ WildFly not found at ' + wildfly_home }}"
          - "{{ '   🔑 Management keystore: ' + ('SUCCESS' if management_keystore_result.rc == 0 else 'FAILED') if wildfly_dir_check.stat.exists else '   ℹ️  Install WildFly first, then run this playbook again' }}"
          - "{{ '   🔑 Application keystore: ' + ('SUCCESS' if application_keystore_result.rc == 0 else 'FAILED') if wildfly_dir_check.stat.exists else '' }}"
          - "{{ '   🔐 Keystore password: production123' if wildfly_dir_check.stat.exists else '' }}"

    - name: Verify certificate validity and dates
      ansible.builtin.shell: |
        openssl x509 -in {{ certificates_dir }}/server.crt -noout -dates -subject
      register: cert_details
      changed_when: false

    - name: Display certificate validity information
      ansible.builtin.debug:
        msg:
          - "📅 Certificate Validity:"
          - "{{ cert_details.stdout_lines }}"

    - name: Test certificate for each subdomain
      ansible.builtin.shell: |
        echo | openssl s_client -connect {{ item.full_domain }}:443 -servername {{ item.full_domain }} -verify_return_error 2>/dev/null | openssl x509 -noout -subject
      register: cert_test
      changed_when: false
      failed_when: false
      loop: "{{ subdomains }}"

    - name: Display per-domain certificate test results
      ansible.builtin.debug:
        msg:
          - "🧪 Certificate Tests (requires domains to be properly configured in DNS):"
          - "   Test results will vary based on DNS configuration"
          - ""
          - "ℹ️  Note: Failed tests are normal if DNS is not yet configured for these subdomains"

    - name: Final setup instructions
      ansible.builtin.debug:
        msg:
          - ""
          - "🚀 Next Steps:"
          - "============="
          - "1. Configure your DNS to point all subdomains to this server's IP:"
          - "   {{ ansible_default_ipv4.address }}"
          - ""
          - "2. DNS Records needed:"
          - "   Point all configured subdomains to {{ ansible_default_ipv4.address }}"
          - ""
          - "3. Update your NGINX configuration to use the new certificate"
          - "4. Restart services: nginx, wildfly, keycloak"
          - ""
          - "5. Test each subdomain:"
          - "   All subdomains from configuration should work with HTTPS"
          - ""
          - "📖 For detailed information, see: {{ certificates_dir }}/README-MultiDomain.txt"